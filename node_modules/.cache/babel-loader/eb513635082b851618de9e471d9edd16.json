{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.randomStr = randomStr;\nexports.param = param;\nexports.getQueryObject = getQueryObject;\nexports.getQueryValue = getQueryValue;\nexports.isArray = isArray;\nexports.isFunction = isFunction;\nexports.isObject = isObject;\nexports.asyncFunc = asyncFunc;\nexports.delay = delay;\nexports.throttle = throttle;\nexports.debounce = debounce;\n/**\r\n  * 生成指定位数的随机数\r\n  * @param {int} x \r\n  */\n\nfunction randomStr(x) {\n  var s = '';\n\n  while (s.length < x && x > 0) {\n    var v = Math.random() < 0.5 ? 32 : 0;\n    s += String.fromCharCode(Math.round(Math.random() * (122 - v - (97 - v)) + (97 - v)));\n  }\n\n  return s;\n}\n/**\r\n * 对像转成url查询字符串\r\n * @param {object} obj \r\n */\n\n\nfunction param(obj, prefix) {\n  var str = [];\n\n  for (var p in obj) {\n    if (obj.hasOwnProperty(p)) {\n      var k = prefix ? prefix + \"[\" + p + \"]\" : p,\n          v = obj[p];\n\n      if (typeof v === \"object\") {\n        var rv = param(v, k);\n        if (rv) str.push(rv);\n      } else {\n        str.push(encodeURIComponent(k) + \"=\" + encodeURIComponent(v));\n      }\n    }\n  }\n\n  return str.join(\"&\");\n}\n/**\r\n * 查询字符串转为对象\r\n * @return {object} {key1: value1, key2: value2}\r\n */\n\n\nfunction getQueryObject() {\n  return function (a) {\n    if (a == '') return {};\n    var b = {};\n\n    for (var i = 0; i < a.length; ++i) {\n      var p = a[i].split('=');\n      if (p.length != 2) continue;\n      b[p[0]] = decodeURIComponent(p[1].replace(/\\+/g, ' '));\n    }\n\n    return b;\n  }(window.location.search.slice(1).split('&'));\n}\n/** \r\n * 取查询字符串中某一个name的value\r\n * @param {string} name \r\n * @param {string} url\r\n * @return {string}\r\n */\n\n\nfunction getQueryValue(name, url) {\n  if (!url) url = window.location.href;\n  name = name.replace(/[\\[\\]]/g, \"\\\\$&\");\n  var regex = new RegExp(\"[?&]\" + name + \"(=([^&#]*)|&|#|$)\");\n  var results = regex.exec(url);\n  if (!results) return null;\n  if (!results[2]) return '';\n  return decodeURIComponent(results[2].replace(/\\+/g, \" \"));\n}\n/**\r\n * 是否为数组\r\n * @param {any} val \r\n */\n\n\nfunction isArray(val) {\n  return Object.prototype.toString.call(val) === '[object Array]';\n}\n/**\r\n * 是否为function\r\n * @param {any} val \r\n */\n\n\nfunction isFunction(val) {\n  return val && {}.toString.call(val) === '[object Function]';\n}\n/**\r\n * 是否为对像\r\n * @param {any} val \r\n */\n\n\nfunction isObject(val) {\n  return val && {}.toString.call(val) === '[object Object]';\n}\n\nfunction asyncFunc(func) {\n  var _arguments = arguments;\n  return function () {\n    return new Promise(function (resolve, reject) {\n      return resolve(isFunction(func) ? resolve(func(_arguments)) : reject(new TypeError(func + 'is not function')));\n    });\n  };\n}\n/**\r\n * 延时任意毫秒\r\n * @param {number} time 毫秒\r\n * 例：\r\n *   delay(500).then(() => console.log('after 500ms'))\r\n */\n\n\nfunction delay() {\n  var time = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  return new Promise(function (res) {\n    return setTimeout(res, time);\n  });\n}\n/**\r\n * 创建并返回一个像节流阀一样的函数，当重复调用函数的时候，最多每隔 wait毫秒调用一次该函数\r\n * @param func 执行函数\r\n * @param wait 时间间隔\r\n * @param options 如果你想禁用第一次首先执行的话，传递{leading: false}，\r\n *                如果你想禁用最后一次执行的话，传递{trailing: false}\r\n * @returns {Function}\r\n */\n\n\nfunction throttle(func, wait, options) {\n  var context, args, result;\n  var timeout = null;\n  var previous = 0;\n  if (!options) options = {};\n\n  var later = function later() {\n    previous = options.leading === false ? 0 : new Date().getTime();\n    timeout = null;\n    result = func.apply(context, args);\n    if (!timeout) context = args = null;\n  };\n\n  return function () {\n    var now = new Date().getTime();\n    if (!previous && options.leading === false) previous = now;\n    var remaining = wait - (now - previous);\n    context = this;\n    args = arguments;\n\n    if (remaining <= 0 || remaining > wait) {\n      if (timeout) {\n        clearTimeout(timeout);\n        timeout = null;\n      }\n\n      previous = now;\n      result = func.apply(context, args);\n      if (!timeout) context = args = null;\n    } else if (!timeout && options.trailing !== false) {\n      timeout = setTimeout(later, remaining);\n    }\n\n    return result;\n  };\n}\n/**\r\n * 防反跳。func函数在最后一次调用时刻的wait毫秒之后执行！\r\n * @param func 执行函数\r\n * @param wait 时间间隔\r\n * @param immediate 为true，debounce会在wai 时间间隔的开始调用这个函数\r\n * @returns {Function}\r\n */\n\n\nfunction debounce(func, wait, immediate) {\n  var timeout, args, context, timestamp, result;\n\n  var later = function later() {\n    var last = new Date().getTime() - timestamp; // timestamp会实时更新\n\n    if (last < wait && last >= 0) {\n      timeout = setTimeout(later, wait - last);\n    } else {\n      timeout = null;\n\n      if (!immediate) {\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      }\n    }\n  };\n\n  return function () {\n    context = this;\n    args = arguments;\n    timestamp = new Date().getTime();\n    var callNow = immediate && !timeout;\n\n    if (!timeout) {\n      timeout = setTimeout(later, wait);\n    }\n\n    if (callNow) {\n      result = func.apply(context, args);\n      context = args = null;\n    }\n\n    return result;\n  };\n}","map":null,"metadata":{},"sourceType":"script"}